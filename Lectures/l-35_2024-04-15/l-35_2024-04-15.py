# ლექცია 35: L35_2024-04-15

# ლექცია ჩატარდა 2024 წლის 15 აპრილს
# თემა: 1. sqlalchemy-ის შესავალი
#       2. 
#          რეალიზაცია

#*******************************************************************#

# საჭირო ბიბლიოთეკების შემოტანა

import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, ForeignKey
from sqlalchemy import Integer, String, CHAR 
from random import choice
#*******************************************************************#

# ლექციის კოდი

Base = declarative_base()  # ამ ბრძანებით ვქმნით Base კლასს, 
# რომელსაც შემდეგ ვიყენებთ როგორც მშობელ კლასს მოდელის კლასების
# შესაქმნელად. Base კლასი აგრეთვე გამოიყენება მოდელის 
# კლასებისგან ბაზაში ცხრილების შესაქმნელად შემდეგი ბრძანებით
# (Base.metadata.create_all(bind=engine)), სადაც engine SQLAlchemy-ის  
# ძრავი, რომელიც დაკავშირებულია ბაზასთან. ეს უკანასკნელი ბრძანება
# კითხულობს პაითონის კოდში განსაზღრულ ყველა მოდელის კლასს 
# (კლასი, რომლის მშობელი კლასიც არის Base) და ავტომატურად 
# აგენერირებს SQL ბრძანებებს, ბაზაში ცხრლების შესაქმნელად, თუ ისინი
# არ არსებობს.

# ქვემოთ მოცემული კლასი წარმოადგენს მოდელს ან მოდელის კლასს და
# ქმნის ცხრილის სტრუქტურას.
# მიღებულია, რომ მოდელის კლასს და ამ კლასით შემქნილ ცხრილს 
# ჰქონდეს ერთი და იგივე სახელი, ოღონდ კლასის სახელი იყოს 
# მხოლობითში, ხოლო ცხრილის სახელი იყოს მრავლობითში.

class Person(Base):
    __tablename__ = "persons" # ცხრილის სახელი.

    # ვქმნით კლასის ატრიბუტებს, რომელიც წარმოადგენს იმ ცხრილის
    # სვეტებს(ატრიბუტებს), რომელიც შეიქმნება ამ კლასისგან.

    id = Column("id", Integer, primary_key=True) # ეს ქმნის ცხრილის
    # სვეტებს, ისე როგორც sql-ში იყო. ვუთითებთ სვეტის(ატრიბუტის)
    # სახელს, სვეტის ტიპს და არის თუ არა ის ცხრილის ძირითადი
    # გასაღები.

    name =  Column("name", String)  # ქმნის ცხრილის სვეტს.
    age = Column("age", Integer)  # ქმნის ცხრილის სვეტს.

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f"Person(name={self.name})"

os.chdir("./lectures/l-35_2024-04-15/dbs/sqlite")
print(os.getcwd())

# engine = create_engine("sqlite:///") # ამ შემთხვევაში ბაზის ფაილს 
# არ შექმნის და ის მხოლოდ RAM-ში იარსებს.

engine = create_engine("sqlite:///mydb.db") # ამ შემთხვევაში ბაზის
# ფაილს შექმნის და ჩაწერს სამუშაო საქაღალდეში.

Base.metadata.create_all(bind=engine)   # ამ შემთხვევაში შექმნის ყველა 
# ცხრილს ყველა იმ კლასისგან, რომლის მშობელი კლასიც არის Base 
# კლასი. საგულისხმოა ის, რომ სწორედ ამ ბრძანების დროს შექმნის 
# ბაზასაც, რომელშიც ჩაწერს ყველა ამ ცხრილს. ამ ბრძანების გაშვებამდე 
# ბაზა არ იქმნება. ზედა ბრძანებით იქმნება მხოლოდ ძრავი, რომელიც
# განსაზღვრავს ბაზის მახასიათებლებს და იმას, თუ სად უნდა იყოს ბაზის 
# ფაილები. იმისათვის, რომ შეიქმნას ბაზა და მისი ფაილები ამას 
# განსაზღვრავს სწორედ არგუმენტი bind, რომელიც ტოლია ძრავის. 
# სწორედ ამ ძრავმა იცის რა ტიპის ბაზა იქმნება და სად უდნა შევინახოთ 
# ეს ბაზა. თუ ბაზა უკვე არსებობს, მაშინ engine განსაზღვრავს ამ 
# ბაზასთან კავშირს. ხოლო ამ უკანსკნაელი ბრძანებით, სწორედ ამ 
# ბაზაში ჩაიწერება ყველა შექმნილი ცხრილი.


names = ["Giorgi", "Mariami", "Elene", "Nika", "Davit"]
ages = [22, 23, 18, 31, 40]

# იმისათვის, რომ ზემოთ, მოდელის კლასში გაწერილ ცხრილში შევიტანო
# ინფორმაცია, ამ კლასისგან უნდა შევქმნა ობიექტი, 
# მასში შევიტანო ინფორმაცია და შემდეგ ეს ობიექტი 
# დავაქომითო. ვინაიდან ბიექტი შექმნილი იქნება მოდელის კლასისგან,
# სესია მიხვდება, რომ ობიექტის ინფორმაცია ამ ცრილში უდნა შეინახოს.
# იმისათვის, რომ ობიექტების დაქომითება და ცხრილში დამატება შევძლო 
# საჭიროა შეიქმნას სესია/სესიის ობიექტი (session). 
# სესია/სესიის ობიექტი არის ის, რაც ახორციელებს
# კავშირს მონაცემთა ბაზასთან. სხვაგვარად კი თარგმნის პაითონში 
# ობიექტების ენაზე დაწერილ კოდს SQL ბრძანებებში. სესია იქმნება
# sessionmaker-ით შექმნილი კლასის Session-ისგან.

Session = sessionmaker(bind=engine)  # ეს ქმნის სესიის კლასს, 
# რომელიც გვჭირდება სესიის ობიექტის შესაქმნელად.

session = Session()  # ეს ქმნის სესიას, რომლის
# საშუალებითაც, engine-ში განსაზღვრულ მონაცემთა ბაზასთან კავშირს
# ვახორციელებთ. სწორედ სესიის ობიექტის გამოყენებით ვამატებთ,
#  ვანახლებთ და ვშლით ცხრილში ინფორმაციას.

person = Person("Levani", 15)  # ამ შემთხვევაში შევქმენი ობიექტი 
# მოდელის კლასისგან, თუმცა ამას ბაზასთან არანაირი კავშირი არ აქვს, 
# მანამ, სანამ ბაზას არ დავუკავშირდები და არ ვეტყვი, რომ ეს ობიექტი 
# დაამატოს იმ ცრილში, საიდანაც ის შეიქმნა. ამის სათქმელად კი
# გვჭირდება, რომ შევქმნათ სესიის ობიექტი (session), რომელიც ზემოთ
# გავაკეთეთ.

session.add(person)  # ამ შემთხვევაში, person ობიექტს დაამატებს სესიის
# ობიექტში, თუმცა ჯერ ბაზაში არ ასახავს. შექმნის დროებით ფაილს
# ბაზის სახელით და გაფართოებით "db-journal", სადაც ეს დამატება
# აისახება.

session.commit()  # ამ ბრძაზნებით დროებით ფაილშია არსებული 
# ინფორმაცია ინტეგრირდება ბაზაშიი, ხოლო დროებითი ფაილი კი 
# წაიშლება. ამ ეტაპზე ხრილშ დამატებული პიროვნება უკვე ბაზაში 
# არსებულ ცხრილშიც აისახება და ჩაიწერება.

all_persons = session.query(Person).all()
print(type(all_persons))
print(all_persons)

# timestamp l35_2024-04-15_00_38_43