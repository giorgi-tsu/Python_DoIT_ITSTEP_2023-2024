# ლექცია 35: L35_2024-04-15

# ლექცია ჩატარდა 2024 წლის 15 აპრილს
# თემა: 1. sqlalchemy-ის შესავალი
#       2. 
#          რეალიზაცია

#*******************************************************************#

# საჭირო ბიბლიოთეკების შემოტანა

import os
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, declarative_base
from sqlalchemy import Column, ForeignKey
from sqlalchemy import Integer, String, CHAR 
from random import choice
#*******************************************************************#

# ლექციის კოდი

Base = declarative_base()  # ამ ბრძანებით ვქმნით Base კლასს, 
# რომელსაც შემდეგ ვიყენებთ როგორც მშობელ კლასს მოდელის კლასების
# შესაქმნელად. Base კლასი აგრეთვე გამოიყენება მოდელის 
# კლასებისგან ბაზაში ცხრილების შესაქმნელად შემდეგი ბრძანებით
# (Base.metadata.create_all(bind=engine)), სადაც engine SQLAlchemy-ის  
# ძრავი, რომელიც დაკავშირებულია ბაზასთან. ეს უკანასკნელი ბრძანება
# კითხულობს პაითონის კოდში განსაზღრულ ყველა მოდელის კლასს 
# (კლასი, რომლის მშობელი კლასიც არის Base) და ავტომატურად 
# აგენერირებს SQL ბრძანებებს, ბაზაში ცხრლების შესაქმნელად, თუ ისინი
# არ არსებობს.

# ქვემოთ მოცემული კლასი წარმოადგენს მოდელს ან მოდელის კლასს და
# ქმნის ცხრილის სტრუქტურას.
# მიღებულია, რომ მოდელის კლასს და ამ კლასით შემქნილ ცხრილს 
# ჰქონდეს ერთი და იგივე სახელი, ოღონდ კლასის სახელი იყოს 
# მხოლობითში, ხოლო ცხრილის სახელი იყოს მრავლობითში.

class Person(Base):
    __tablename__ = "persons" # ცხრილის სახელი.

    # ვქმნით კლასის ატრიბუტებს, რომელიც წარმოადგენს იმ ცხრილის
    # სვეტებს(ატრიბუტებს), რომელიც შეიქმნება ამ კლასისგან.

    id = Column("id", Integer, primary_key=True) # ეს ქმნის ცხრილის
    # სვეტებს, ისე როგორც sql-ში იყო. ვუთითებთ სვეტის(ატრიბუტის)
    # სახელს, სვეტის ტიპს და არის თუ არა ის ცხრილის ძირითადი
    # გასაღები.

    name =  Column("name", String)  # ქმნის ცხრილის სვეტს.
    age = Column("age", Integer)  # ქმნის ცხრილის სვეტს.

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self, name):
        return f"Person(name={self.name})"

os.chdir("./lectures/l-35_2024-04-15/dbs/sqlite")
print(os.getcwd())

# engine = create_engine("sqlite:///") # ამ შემთხვევაში ბაზის ფაილს 
# არ შექმნის და ის მხოლოდ RAM-ში იარსებს.

engine = create_engine("sqlite:///mydb.db") # ამ შემთხვევაში ბაზის
# ფაილს შექმნის და ჩაწერს სამუშაო საქაღალდეში.

Base.metadata.create_all(bind=engine)   # ამ შემთხვევაში შექმნის ყველა 
# ცხრილს ყველა იმ კლასისგან, რომლის მშობელი კლასიც არის Base 
# კლასი. საგულისხმოა ის, რომ სწორედ ამ ბრძანების დროს შექმნის 
# ბაზასაც, რომელშიც ჩაწერს ყველა ამ ცხრილს. ამ ბრძანების გაშვებამდე 
# ბაზა არ იქმნება. ზედა ბრძანებით იქმნება მხოლოდ ძრავი, რომელიც
# განსაზღვრავს ბაზის მახასიათებლებს და იმას, თუ სად უნდა იყოს ბაზის 
# ფაილები. იმისათვის, რომ შეიქმნას ბაზა და მისი ფაილები ამას 
# განსაზღვრავს სწორედ არგუმენტი bind, რომელიც ტოლია ძრავის. 
# სწორედ ამ ძრავმა იცის რა ტიპის ბაზა იქმნება და სად უდნა შევინახოთ 
# ეს ბაზა. თუ ბაზა უკვე არსებობს, მაშინ engine განსაზღვრავს ამ 
# ბაზასთან კავშირს. ხოლო ამ უკანსკნაელი ბრძანებით, სწორედ ამ 
# ბაზაში ჩაიწერება ყველა შექმნილი ცხრილი.


names = ["Giorgi", "Mariami", "Elene", "Nika", "Davit"]
ages = [22, 23, 18, 31, 40]

# იმისათვის, რომ ზემოთ მოდელის კლასში გაწერილ ცხრილში შევიტანო
# ინფორმაცია, ამ კლასისგან უნდა შევქმნა ობიექტი და შემდეგ ეს ობიექტი 
# დავაქომითო. ვინაიდან ბიექტი შექმნილი იქნება მოდელის კლასისგან,
# სესია მიხვდება, რომ ობიექტის ინფორმაცია ამ ცრილში უდნა შეინახოს.
# იმისათვის, რომ ობიექტების დაქომითება შევძლო და ცხრილში დამატება 
# საჭიროა შეიქმნას სესია (session). სესია არის ის, რაც ახორციელებს
# კავშირს მონაცემთა ბაზასთან. სხვაგვარად კი თარგმნის პაითონში 
# ობიექტების ენაზე დაწერილ კოდს SQL ბრძანებებში.

















