# ლექცია 35: L35_2024-04-15

# ლექცია ჩატარდა 2024 წლის 15 აპრილს
# თემა: 1. sqlalchemy-ის შესავალი
#       2. 

#*******************************************************************#

# საჭირო ბიბლიოთეკების შემოტანა

import os
from sqlalchemy import create_engine
from sqlalchemy.orm import declarative_base, sessionmaker
from sqlalchemy import Column, ForeignKey
from sqlalchemy import Integer, String, CHAR 
from random import choice

#*******************************************************************#

# ლექციის კოდი

Base = declarative_base()  # ამ ბრძანებით ვქმნით Base კლასს, 
# რომელსაც შემდეგ ვიყენებთ როგორც მშობელ კლასს მოდელის კლასების
# შესაქმნელად. მოდელის კლასი წარმოადგენს კლასს, რომელშიც გაწერილია
# SQL ცხრილის სტრუქტურა (ცხრილის სახელი, სვეტები და
# სვეტების მაასიათებლები). ცხრილის სახელი, სვეტები და
# სვეტების მახასიათებლები წაარმოადგენენ კლასის ატრიბუტებს. 
# გარდა ამისა, Base კლასს აქვს კონტრუქტორიც, რომელიც გამოიყენება 
# ამ კლასისგან ობიექტის შესაქმნელად. ობიექტი კი საჭიროა კლასისგან 
# შექმნილ ცხრილში მონაცემების დასამატებლაად. სწორედ ამ კლასისგან
# შექმნილი ობიექტის ატრიბუტების მნიშვნელობები შეგვიძლია დავამატოთ
# ამავე კლასისგან შექმნილ ცხრილში. Base კლასი აგრეთვე გამოიყენება
# მოდელის კლასებისგან ბაზაში ცხრილების შესაქმნელად შემდეგი
# ბრძანებით (Base.metadata.create_all(bind=engine)),
# სადაც engine არის SQLAlchemy-ის ძრავი,
# რომელიც დაკავშირებულია ბაზასთან. ეს უკანასკნელი ბრძანება
# კითხულობს პაითონის კოდში განსაზღრულ ყველა მოდელის კლასს 
# (კლასი, რომლის მშობელი კლასიც არის Base) და ავტომატურად 
# აგენერირებს SQL ბრძანებებს, ბაზაში ცხრლების შესაქმნელად, თუ ისინი
# არ არსებობს.

# ქვემოთ მოცემული კლასი წარმოადგენს მოდელს ან მოდელის კლასს და
# ქმნის ცხრილის სტრუქტურას.
# მიღებულია, რომ მოდელის კლასს და ამ კლასით შემქნილ ცხრილს 
# ჰქონდეს ერთი და იგივე სახელი, ოღონდ კლასის სახელი იყოს 
# მხოლობითში, ხოლო ცხრილის სახელი იყოს მრავლობითში.

class Person(Base):
    __tablename__ = "persons" # ცხრილის სახელი.

    # ვქმნით კლასის ატრიბუტებს, რომელიც წარმოადგენს იმ ცხრილის
    # სვეტებს(ატრიბუტებს), რომელიც შეიქმნება ამ კლასისგან.

    id = Column("id", Integer, primary_key=True) # ეს ქმნის ცხრილის
    # სვეტებს, ისე როგორც sql-ში იყო. ვუთითებთ სვეტის(ატრიბუტის)
    # სახელს, სვეტის ტიპს და არის თუ არა ის ცხრილის ძირითადი
    # გასაღები.

    name =  Column("name", String)  # ქმნის ცხრილის სვეტს.
    age = Column("age", Integer)  # ქმნის ცხრილის სვეტს.

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __repr__(self):
        return f"Person(name={self.name}, age={self.age})"

os.chdir("./lectures/l-35_2024-04-15/dbs/sqlite")
print(os.getcwd())

# engine აკავშირებს Python-ს მონაცემთა ბაზასთან. იმ შემთხვევაში, თუ
# მონაცემთა ბაზა არ არსებობს მაშინ ის შექმნის SQLite-ის მონაცემთა 
# ბაზას მიმდინარე სამუშაო დირექტორიაში.

# engine = create_engine("sqlite:///") # ამ შემთხვევაში ბაზის ფაილს 
# არ შექმნის და ის მხოლოდ RAM-ში იარსებს.

# ქვემოთ მოცემული ბლოკი ამოწმებს არსებობს თუ არა ბაზის ფაილი. თუ
# არსებობს, ბაზის ფაილი წაიშლება და შეიქმნება ახალი. ეს მჭირდება
# სასწავლო მიზნისთვის, რათა ჩანაწერები არ განმორდეს და შევძლო 
# კარგად გაგება იმისა თუ რა ხდება. სხვა ალტერნატივა იქნებდა საერთოდ
# არ შემექმნა ბაზის ფაილი და ოპერატიულ მეხსიერებაში მქონოდა ბაზა,  
# მაგრამ ასე ჯობია, რადგან გარედანაც ვნახავ რას ამატებს ბაზაში და რას 
# არა.

database_path = "mydb.db"
if os.path.exists(database_path ):
    os.remove(database_path)

engine = create_engine("sqlite:///mydb.db") # ამ შემთხვევაში ბაზის
# ფაილს შექმნის და ჩაწერს სამუშაო საქაღალდეში.

Base.metadata.create_all(bind=engine)   # როგორც ზემოთ ვთქვით 
# მოცემული ბრზანება შექმნის ცხრილებს ყველა იმ კლასისგან, რომლის
# მშობელი კლასიც არის Base კლასი. საგულისხმოა ის, რომ სწორედ
# ამ ბრძანების დროს შექმნის ბაზასაც, რომელშიც ჩაწერს ყველა ამ ცხრილს.
# ამ ბრძანების გაშვებამდე ბაზა არ იქმნება. ზედა ბრძანებით იქმნება
# მხოლოდ ძრავი, რომელიც განსაზღვრავს ბაზის მახასიათებლებს და
#  იმას, თუ სად უნდა იყოს ბაზის ფაილები (თუ ბაზა უკვე არსებობს,
# მაშნ განსაზღვრავს იმას თუ რომელ ბაზას უნდა დაუკავშირდეს).
# იმისათვის, რომ შეიქმნას ბაზა და მისი ფაილები ამას 
# განსაზღვრავს სწორედ არგუმენტი bind, რომელიც ტოლია ძრავის. 
# სწორედ ამ ძრავმა იცის რა ტიპის ბაზა იქმნება და სად უდნა შევინახოთ 
# ეს ბაზა. თუ ბაზა უკვე არსებობს, მაშინ engine განსაზღვრავს ამ 
# ბაზასთან კავშირს. ხოლო ამ უკანსკნაელი ბრძანებით, სწორედ ამ 
# ბაზაში ჩაიწერება ყველა შექმნილი ცხრილი.


# იმისათვის, რომ ზემოთ, მოდელის კლასში გაწერილ ცხრილში შევიტანო
# ინფორმაცია, ამ კლასისგან უნდა შევქმნა ობიექტი, 
# მასში შევიტანო ინფორმაცია და შემდეგ ეს ობიექტი 
# დავაქომითო. ვინაიდან ბიექტი შექმნილი იქნება მოდელის კლასისგან,
# სესია მიხვდება, რომ ობიექტის ინფორმაცია ამ ცრილში უდნა შეინახოს.
# იმისათვის, რომ ობიექტების დაქომითება და ცხრილში დამატება შევძლო 
# საჭიროა შეიქმნას სესია/სესიის ობიექტი (session). 
# სესია/სესიის ობიექტი არის ის, რაც ახორციელებს
# კავშირს მონაცემთა ბაზასთან. სხვაგვარად კი თარგმნის პაითონში 
# ობიექტების ენაზე დაწერილ კოდს SQL ბრძანებებში. სესია იქმნება
# sessionmaker-ით შექმნილი კლასის Session-ისგან.

Session = sessionmaker(bind=engine)  # ეს ქმნის სესიის კლასს, 
# რომელიც გვჭირდება სესიის ობიექტის შესაქმნელად.

session = Session()  # ეს ქმნის სესიას, რომლის
# საშუალებითაც, engine-ში განსაზღვრულ მონაცემთა ბაზასთან კავშირს
# ვახორციელებთ. სწორედ სესიის ობიექტის გამოყენებით ვამატებთ,
# ვანახლებთ და ვშლით ცხრილში ინფორმაციას.

person = Person("Levani", 15)  # ამ შემთხვევაში შევქმენი ობიექტი 
# მოდელის კლასისგან, თუმცა ამას ბაზასთან არანაირი კავშირი არ აქვს, 
# მანამ, სანამ ბაზას არ დავუკავშირდები და არ ვეტყვი, რომ ეს ობიექტი 
# დაამატოს იმ ცრილში, საიდანაც ის შეიქმნა. ამის სათქმელად კი
# გვჭირდება, რომ შევქმნათ სესიის ობიექტი (session), რომელიც ზემოთ
# გავაკეთეთ.

session.add(person)  # ამ შემთხვევაში, person ობიექტს დაამატებს სესიის
# ობიექტში, თუმცა ჯერ ბაზაში არ ასახავს. შექმნის დროებით ფაილს
# ბაზის სახელით და გაფართოებით "db-journal", სადაც ეს დამატება
# აისახება.

session.commit()  # ამ ბრძაზნებით დროებით ფაილშია არსებული 
# ინფორმაცია ინტეგრირდება ბაზაში, ხოლო დროებითი ფაილი კი 
# წაიშლება. ამ ეტაპზე ცხრილში დამატებული პიროვნება უკვე ბაზაში 
# არსებულ ცხრილშიც აისახება და ჩაიწერება.

# all_persons = session.query(Person).all()  # ამ ბრძანებით, მოგვაქვს
# ბაზაში არსებული persons ცხრილი. ცხრილი მოაქვს პაითონის სისს 
# სახით.

# print(all_persons)  # ამ შეთხვევავში წამოიღბს მხოლოდ 
# [Person(name=Levani, age=15)] მონაცემს. 

# timestamp l35_2024-04-15_00_38_43

# ეხლა კი, ჩვენს მიერ შექმნილ ცხრილში დავამატოთ რაამდენიმე 
# ინფორმაცია. ამისთვის უნდა შევქმნათ იმდენი ობიექტი Person კლასისგან
# რამდენი სტრიქონიც გვინდა რომ დაამატოს ცხრილში.

names = ["Giorgi", "Mariami", "Elene", "Nika", "Davit"]
ages = [22, 23, 18, 31, 40]

# for n in names:
#     for a in ages:
#         person = Person(n, a)
#         session.add(person)

# ზემოთ მოცემული ციკლი თითოეულ მონაცემს სათითაოდ ამატებს 
# ცხრილში. ამის ალტერნატივაა, რომ ჯერ შევქმნათ სია ყველაა იმ 
# ობიექტისა, რომელიც გვიდნა რომ სიაში დაემატოს და შემდეგ ეს სია
# ერთიანად დავამატოთ ბაზაში session.add_all()-ის გამოყენებით.

people = []

for n in names:
    for a in ages:
        people.append(Person(n, a))

session.add_all(people)  # ერთიანად დაამატებს მთლიან სიას ბაზაში 
# ოღონდ როგორც ავხსენი დროებით ფაილში. 

session.commit()  # დროებით ფაილს ჩაწერს ბაზაში.

print(len(session.query(Person).all()))  # გამოიტანს ცხრილში
# არსებულ ყველა მონაცემის რაოდენობას. სხვაგვარად, ცხრილის სიგრძეს.


##### ეხლა კი დავიწყოთ SQL ბრძანებებზე ვარჯიში.

# ყველას მონიშვნა
# all_persons = session.query(Person).all()  # ამ შემთხვევაში გამოაქვს
# ყველა სვეტის ყველა ჩანაწერი პაითონის სიის სახით.

# print(all_persons[0])  # გამოიტანს ცხრილის პირველ ჩანაწერს. 

# მაგალითად ეხლა რომ ჩვენ გვინდა გავფილტროთ სია რაღაცის მიხედვით.

# სიის გასაფილტრად გვაქვს ორი მეთოდი filter და filter_by და 
# ქვემოთ განვიხილავთ ორივეს. 

# all_persons = session.query(Person).filter_by(name="Giorgi").all()
#  ამ შემთხვევაში წამოიღებს ყველა იმ ჩანაწერს სადაც სახელი არის Giorgi.
# print(all_persons)

# all_persons = session.query(Person).filter_by(age=22).all()
#  ამ შემთხვევაში წამოიღებს ყველა იმ ჩანაწერს, სადაც ასაკი არის 22.
# print(all_persons)

# all_persons = session.query(Person).filter_by(name="Giorgi", age=22)\
#     .all()
# #  ამ შემთხვევაში წამოიღებს ყველა იმ ჩანაწერს სადაც სახელი არის Giorgi.
# # და ასაკია რის 22

# print(all_persons)


# all_persons = session.query(Person).filter(Person.age>22).all()
#  ამ შემთხვევაში წამოიღებს ყველა იმ ჩანაწერს, სადაც ასაკი არის 
# 22-ზე მეტი

# print(all_persons)

# all_persons = session.query(Person).filter(Person.age == 22).all()
# #  ამ შემთხვევაში წამოიღებს ყველა იმ ჩანაწერს, სადაც ასაკი არის 
# # 22.

# print(all_persons)


# all_persons = session.query(Person).filter(Person.age > 22)\
#     .filter(Person.age < 30).all()
# #  ამ შემთხვევაში წამოიღებს ყველა იმ ჩანაწერს, სადაც ასაკი არის 
# # 22-ზე მეტი და 30-ზე ნაკლები.

# print(all_persons)


# all_persons = session.query(Person).filter((Person.age > 22)\
#                                             & (Person.age < 30)).all()
# # ამ შემთხვევაში წამოიღებს ყველა იმ ჩანაწერს, სადაც ასაკი არის 
# # 22-ზე მეტი და 30-ზე ნაკლები.

# print(all_persons)


person_Giorgi = session.query(Person).filter_by(name="Giorgi")\
    .first()
# ამ შემთხვევაში წამოიღებს პირველვე ჩანაწერს, სადაც სახელი არის Giorgi.
# მნიშვნელოვანია მივაქციოთ ყურადღება, რომ ამ შემთხვევაში ეს აბრუნებს
# კლასს.
print(person_Giorgi)
print(type(person_Giorgi))


# იგივეს გაკეთება შეგვიძლია იმ შემთხვევაში, თუ ჯერ დავაბრუნებთ 
# კლასსების სიას ხოლო შემდეგ კი იდენქსით ამოვიღებთ პირველს.
person_Giorgi = session.query(Person).filter_by(name="Giorgi")\
    .all()[0]

print(person_Giorgi)
print(type(person_Giorgi))

# შეგვიძლია ამოვიღოთ მეორეც, რომელიც არის Giorgi 23 წლის.
person_Giorgi = session.query(Person).filter_by(name="Giorgi")\
    .all()[1]

print(person_Giorgi)
print(type(person_Giorgi))

# იმისათვის, რომ მონაცემთა ბაზიდან წავშალო ჩანაწერი, მჭირდება
# ვიპოვო ის როგორც კლასი და გადავცე სესიის წაშლის მეთოდს.
# მაგალითად, მიდნა წავშალო Giorgi 23 წლის.

session.delete(person_Giorgi)  # ეს წაშლის დროებითი ბაზიდან.

all_Giorgi = session.query(Person).filter_by(name="Giorgi")\
    .all()
print(all_Giorgi)

# იმისათვის, რომ ძირითადი ბაზის ფაილიდანაც წავშალოთ საჭიროა 
# გავუკეთოთ ქომითი.

session.commit()

